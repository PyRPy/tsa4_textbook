---
title: "Chapter5_AdditionalTimeDomainTopics"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## load required packages
```{r}
library('astsa')
source('grid.r')
```
### Example 5.1 Long Memory Fitting of the Glacial Varve Series
```{r}
ACF  =  acf(log(varve), 100, plot=FALSE)
plot(ACF[1:100], xlab="LAG", ylim=c(-.05,1), panel.first=grid(lty=1))
abline(h=0)
```
```{r}
d  = 0.3841688
p = rep(1,31)
for (k in 1:30){ p[k+1] = (k-d)*p[k]/(k+1) }
plot(1:30, p[-1], ylab=expression(pi(d)), lwd=2, xlab="Index", type="h", panel.first=grid(lty=1))
```
```{r message=FALSE}
library(fracdiff)
# I might suggest another package such as 'arfima' because 
# this package gives questionable results and it's not easy to
# pull out the residuals
lvarve = log(varve)-mean(log(varve))
varve.fd = fracdiff(lvarve, nar=0, nma=0, M=30)
#varve.fd$d  # = 0.3841688
#varve.fd$stderror.dpq  # = 4.589514e-06 (questionable result!!)
res.fd = diffseries(log(varve), varve.fd$d)  # frac diff resids
res.arima = resid(arima(log(varve), order=c(1,1,1))) # arima resids
par(mfrow=c(2,1), mar=c(2,2.5,.5,0)+.5, mgp=c(1.4,.6,0))
acf(res.arima, 100, xlim=c(4,97), ylim=c(-.2,.2), main="", xlab="LAG", panel.first=grid(lty=1))
acf(res.fd, 100, xlim=c(4,97), ylim=c(-.2,.2), main="", xlab="LAG", panel.first=grid(lty=1))
```
```{r}
library(arfima)
summary(varve.fd <- arfima(log(varve)))  # d.hat = 0.3728, se(d,hat) = 0.0273
# residual stuff
innov = resid(varve.fd)  
plot.ts(innov[[1]])  
acf(innov[[1]])  

## ... much better ...  sorry I didn't ...
## ... get it in for the newest edition ..
## ... once in awhile, they slip on by ...
```
### Example 5.2 Long Memory Spectra for the Varve Series
```{r}
series = log(varve) - mean(log(varve)) # specify series to be analyzed
d0 = .1                                # initial value of d
n.per = nextn(length(series))
m=(n.per)/2  - 1
per = abs(fft(series)[-1])^2  # remove 0 freq
per = per/n.per               # R doesn't scale fft by sqrt(n)
g = 4*(sin(pi*((1:m)/n.per))^2)

# Function to calculate -log.likelihood
whit.like = function(d){
	g.d=g^d
    sig2 = (sum(g.d*per[1:m])/m)
    log.like = m*log(sig2) + d*sum(log(g)) + m
    return(log.like)
    }	

# -- Estimation --
est=optim(d0,whit.like,gr=NULL,method="L-BFGS-B",hessian=TRUE,
           lower=-.5,upper=.5)
#cat("d.hat =", est$par,"se(dhat) =", 1/sqrt(est$hessian), "\n")
g.dhat=g^est$par;  sig2=sum(g.dhat*per[1:m])/m
#cat("sig2hat=",sig2, "\n")  

#  spectral approach
u = spec.ar(log(varve), plot=FALSE)  #produces ar(8)
g= 4*(sin(pi*((1:500)/2000))^2)
fhat = sig2*g^{-est$par} # long memory spectral estimate

plot(1:500/2000, log(fhat), type="l", ylab="log(spectrum)", xlab="frequency",  panel.first=grid(lty=1))

lines(u$freq[1:250], log(u$spec[1:250]), lty="dashed")
```
```{r}
library(fracdiff)
fdGPH(log(varve), bandw = .9)  # fdGPH doesn't seem to work very well either
```
```{r}
# page - 249
ar.mle(log(varve)) # to get AR(8) estimates
```
### Example 5.3 Testing Unit Roots in the Glacial Varve Series
https://www.stat.pitt.edu/stoffer/tsa4/Rexamples.htm
```{r message=FALSE}
library(tseries)
adf.test(log(varve), k=0)  # DF test
adf.test(log(varve))       # ADF test
pp.test(log(varve))        # PP test
```
* In each test, we reject the null hypothesis that the logged varve series has a unit
root. The conclusion of these tests supports the conclusion of the previous section
that the logged varve series is long memory rather than integrated.
